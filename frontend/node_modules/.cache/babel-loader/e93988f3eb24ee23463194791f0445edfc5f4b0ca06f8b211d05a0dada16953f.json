{"ast":null,"code":"import { ref, watch, computed, reactive, defineComponent, createVNode as _createVNode } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp, LONG_PRESS_START_TIME } from \"../utils/index.mjs\";\nimport { useExpose } from \"../composables/use-expose.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { raf, useEventListener, useRect } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\nconst getDistance = touches => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\nconst getCenter = touches => ({\n  x: (touches[0].clientX + touches[1].clientX) / 2,\n  y: (touches[0].clientY + touches[1].clientY) / 2\n});\nconst bem = createNamespace(\"image-preview\")[1];\nconst longImageRatio = 2.6;\nconst imagePreviewItemProps = {\n  src: String,\n  show: Boolean,\n  active: Number,\n  minZoom: makeRequiredProp(numericProp),\n  maxZoom: makeRequiredProp(numericProp),\n  rootWidth: makeRequiredProp(Number),\n  rootHeight: makeRequiredProp(Number),\n  disableZoom: Boolean,\n  doubleScale: Boolean,\n  closeOnClickImage: Boolean,\n  closeOnClickOverlay: Boolean,\n  vertical: Boolean\n};\nvar stdin_default = defineComponent({\n  props: imagePreviewItemProps,\n  emits: [\"scale\", \"close\", \"longPress\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      initializing: false,\n      imageRatio: 0\n    });\n    const touch = useTouch();\n    const imageRef = ref();\n    const swipeItem = ref();\n    const vertical = ref(false);\n    const isLongImage = ref(false);\n    let initialMoveY = 0;\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming,\n        initializing\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving || initializing ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1 || isLongImage.value) {\n        style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;\n      }\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n      return 0;\n    });\n    const setScale = (scale, center) => {\n      var _a;\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        const ratio = scale / state.scale;\n        state.scale = scale;\n        if (center) {\n          const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);\n          const origin = {\n            x: imageRect.width * 0.5,\n            y: imageRect.height * 0.5\n          };\n          const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);\n          const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);\n          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n        } else {\n          state.moveX = 0;\n          state.moveY = isLongImage.value ? initialMoveY : 0;\n        }\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale, scale === 2 || isLongImage.value ? {\n        x: touch.startX.value,\n        y: touch.startY.value\n      } : void 0);\n    };\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let lastCenter;\n    let doubleTapTimer;\n    let touchStartTime;\n    let isImageMoved = false;\n    const onTouchStart = event => {\n      const {\n        touches\n      } = event;\n      fingerNum = touches.length;\n      if (fingerNum === 2 && props.disableZoom) {\n        return;\n      }\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      isImageMoved = false;\n      state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);\n      state.zooming = fingerNum === 2 && !offsetX.value;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(touches);\n      }\n    };\n    const onTouchMove = event => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        if ((props.vertical ? touch.isVertical() && Math.abs(moveY) > maxMoveY.value : touch.isHorizontal() && Math.abs(moveX) > maxMoveX.value) && !isImageMoved) {\n          state.moving = false;\n          return;\n        }\n        isImageMoved = true;\n        preventDefault(event, true);\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n      if (state.zooming) {\n        preventDefault(event, true);\n        if (touches.length === 2) {\n          const distance = getDistance(touches);\n          const scale = startScale * distance / startDistance;\n          lastCenter = getCenter(touches);\n          setScale(scale, lastCenter);\n        }\n      }\n    };\n    const checkClose = event => {\n      var _a;\n      const swipeItemEl = (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      if (!swipeItemEl) return;\n      const imageEl = swipeItemEl.firstElementChild;\n      const isClickOverlay = event.target === swipeItemEl;\n      const isClickImage = imageEl == null ? void 0 : imageEl.contains(event.target);\n      if (!props.closeOnClickImage && isClickImage) return;\n      if (!props.closeOnClickOverlay && isClickOverlay) return;\n      emit(\"close\");\n    };\n    const checkTap = event => {\n      if (fingerNum > 1) {\n        return;\n      }\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      if (touch.isTap.value) {\n        if (deltaTime < TAP_TIME) {\n          if (props.doubleScale) {\n            if (doubleTapTimer) {\n              clearTimeout(doubleTapTimer);\n              doubleTapTimer = null;\n              toggleScale();\n            } else {\n              doubleTapTimer = setTimeout(() => {\n                checkClose(event);\n                doubleTapTimer = null;\n              }, TAP_TIME);\n            }\n          } else {\n            checkClose(event);\n          }\n        } else if (deltaTime > LONG_PRESS_START_TIME) {\n          emit(\"longPress\");\n        }\n      }\n    };\n    const onTouchEnd = event => {\n      let stopPropagation = false;\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          const maxZoom = +props.maxZoom;\n          if (state.scale > maxZoom) {\n            setScale(maxZoom, lastCenter);\n          }\n        }\n      }\n      preventDefault(event, stopPropagation);\n      checkTap(event);\n      touch.reset();\n    };\n    const resize = () => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      const {\n        imageRatio\n      } = state;\n      vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;\n      isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;\n      if (isLongImage.value) {\n        initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;\n        state.moveY = initialMoveY;\n        state.initializing = true;\n        raf(() => {\n          state.initializing = false;\n        });\n      }\n      resetScale();\n    };\n    const onLoad = event => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n      resize();\n    };\n    watch(() => props.active, resetScale);\n    watch(() => props.show, value => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    watch(() => [props.rootWidth, props.rootHeight], resize);\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    useExpose({\n      resetScale\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src,\n          onLoad,\n          style: imageStyle.value\n        })]) : _createVNode(Image, {\n          \"ref\": imageRef,\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n});\nexport { stdin_default as default };","map":{"version":3,"names":["ref","watch","computed","reactive","defineComponent","createVNode","_createVNode","clamp","numericProp","preventDefault","createNamespace","makeRequiredProp","LONG_PRESS_START_TIME","useExpose","useTouch","raf","useEventListener","useRect","Image","Loading","SwipeItem","getDistance","touches","Math","sqrt","clientX","clientY","getCenter","x","y","bem","longImageRatio","imagePreviewItemProps","src","String","show","Boolean","active","Number","minZoom","maxZoom","rootWidth","rootHeight","disableZoom","doubleScale","closeOnClickImage","closeOnClickOverlay","vertical","stdin_default","props","emits","setup","emit","slots","state","scale","moveX","moveY","moving","zooming","initializing","imageRatio","touch","imageRef","swipeItem","isLongImage","initialMoveY","imageStyle","style","transitionDuration","value","transform","maxMoveX","displayWidth","max","maxMoveY","displayHeight","setScale","center","_a","ratio","imageRect","$el","origin","width","height","left","top","index","resetScale","toggleScale","startX","startY","fingerNum","startMoveX","startMoveY","startScale","startDistance","lastCenter","doubleTapTimer","touchStartTime","isImageMoved","onTouchStart","event","length","offsetX","start","Date","now","onTouchMove","move","deltaX","deltaY","isVertical","abs","isHorizontal","distance","checkClose","swipeItemEl","imageEl","firstElementChild","isClickOverlay","target","isClickImage","contains","checkTap","deltaTime","TAP_TIME","isTap","clearTimeout","setTimeout","onTouchEnd","stopPropagation","reset","resize","rootRatio","onLoad","naturalWidth","naturalHeight","imageSlots","loading","default","image"],"sources":["C:/Users/123/Desktop/开发八字命理AI指导功能页码/frontend/node_modules/vant/es/image-preview/ImagePreviewItem.mjs"],"sourcesContent":["import { ref, watch, computed, reactive, defineComponent, createVNode as _createVNode } from \"vue\";\nimport { clamp, numericProp, preventDefault, createNamespace, makeRequiredProp, LONG_PRESS_START_TIME } from \"../utils/index.mjs\";\nimport { useExpose } from \"../composables/use-expose.mjs\";\nimport { useTouch } from \"../composables/use-touch.mjs\";\nimport { raf, useEventListener, useRect } from \"@vant/use\";\nimport { Image } from \"../image/index.mjs\";\nimport { Loading } from \"../loading/index.mjs\";\nimport { SwipeItem } from \"../swipe-item/index.mjs\";\nconst getDistance = (touches) => Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\nconst getCenter = (touches) => ({\n  x: (touches[0].clientX + touches[1].clientX) / 2,\n  y: (touches[0].clientY + touches[1].clientY) / 2\n});\nconst bem = createNamespace(\"image-preview\")[1];\nconst longImageRatio = 2.6;\nconst imagePreviewItemProps = {\n  src: String,\n  show: Boolean,\n  active: Number,\n  minZoom: makeRequiredProp(numericProp),\n  maxZoom: makeRequiredProp(numericProp),\n  rootWidth: makeRequiredProp(Number),\n  rootHeight: makeRequiredProp(Number),\n  disableZoom: Boolean,\n  doubleScale: Boolean,\n  closeOnClickImage: Boolean,\n  closeOnClickOverlay: Boolean,\n  vertical: Boolean\n};\nvar stdin_default = defineComponent({\n  props: imagePreviewItemProps,\n  emits: [\"scale\", \"close\", \"longPress\"],\n  setup(props, {\n    emit,\n    slots\n  }) {\n    const state = reactive({\n      scale: 1,\n      moveX: 0,\n      moveY: 0,\n      moving: false,\n      zooming: false,\n      initializing: false,\n      imageRatio: 0\n    });\n    const touch = useTouch();\n    const imageRef = ref();\n    const swipeItem = ref();\n    const vertical = ref(false);\n    const isLongImage = ref(false);\n    let initialMoveY = 0;\n    const imageStyle = computed(() => {\n      const {\n        scale,\n        moveX,\n        moveY,\n        moving,\n        zooming,\n        initializing\n      } = state;\n      const style = {\n        transitionDuration: zooming || moving || initializing ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1 || isLongImage.value) {\n        style.transform = `matrix(${scale}, 0, 0, ${scale}, ${moveX}, ${moveY})`;\n      }\n      return style;\n    });\n    const maxMoveX = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;\n        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);\n      }\n      return 0;\n    });\n    const maxMoveY = computed(() => {\n      if (state.imageRatio) {\n        const {\n          rootWidth,\n          rootHeight\n        } = props;\n        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;\n        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);\n      }\n      return 0;\n    });\n    const setScale = (scale, center) => {\n      var _a;\n      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        const ratio = scale / state.scale;\n        state.scale = scale;\n        if (center) {\n          const imageRect = useRect((_a = imageRef.value) == null ? void 0 : _a.$el);\n          const origin = {\n            x: imageRect.width * 0.5,\n            y: imageRect.height * 0.5\n          };\n          const moveX = state.moveX - (center.x - imageRect.left - origin.x) * (ratio - 1);\n          const moveY = state.moveY - (center.y - imageRect.top - origin.y) * (ratio - 1);\n          state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n          state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n        } else {\n          state.moveX = 0;\n          state.moveY = isLongImage.value ? initialMoveY : 0;\n        }\n        emit(\"scale\", {\n          scale,\n          index: props.active\n        });\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n      setScale(scale, scale === 2 || isLongImage.value ? {\n        x: touch.startX.value,\n        y: touch.startY.value\n      } : void 0);\n    };\n    let fingerNum;\n    let startMoveX;\n    let startMoveY;\n    let startScale;\n    let startDistance;\n    let lastCenter;\n    let doubleTapTimer;\n    let touchStartTime;\n    let isImageMoved = false;\n    const onTouchStart = (event) => {\n      const {\n        touches\n      } = event;\n      fingerNum = touches.length;\n      if (fingerNum === 2 && props.disableZoom) {\n        return;\n      }\n      const {\n        offsetX\n      } = touch;\n      touch.start(event);\n      startMoveX = state.moveX;\n      startMoveY = state.moveY;\n      touchStartTime = Date.now();\n      isImageMoved = false;\n      state.moving = fingerNum === 1 && (state.scale !== 1 || isLongImage.value);\n      state.zooming = fingerNum === 2 && !offsetX.value;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(touches);\n      }\n    };\n    const onTouchMove = (event) => {\n      const {\n        touches\n      } = event;\n      touch.move(event);\n      if (state.moving) {\n        const {\n          deltaX,\n          deltaY\n        } = touch;\n        const moveX = deltaX.value + startMoveX;\n        const moveY = deltaY.value + startMoveY;\n        if ((props.vertical ? touch.isVertical() && Math.abs(moveY) > maxMoveY.value : touch.isHorizontal() && Math.abs(moveX) > maxMoveX.value) && !isImageMoved) {\n          state.moving = false;\n          return;\n        }\n        isImageMoved = true;\n        preventDefault(event, true);\n        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);\n        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);\n      }\n      if (state.zooming) {\n        preventDefault(event, true);\n        if (touches.length === 2) {\n          const distance = getDistance(touches);\n          const scale = startScale * distance / startDistance;\n          lastCenter = getCenter(touches);\n          setScale(scale, lastCenter);\n        }\n      }\n    };\n    const checkClose = (event) => {\n      var _a;\n      const swipeItemEl = (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      if (!swipeItemEl) return;\n      const imageEl = swipeItemEl.firstElementChild;\n      const isClickOverlay = event.target === swipeItemEl;\n      const isClickImage = imageEl == null ? void 0 : imageEl.contains(event.target);\n      if (!props.closeOnClickImage && isClickImage) return;\n      if (!props.closeOnClickOverlay && isClickOverlay) return;\n      emit(\"close\");\n    };\n    const checkTap = (event) => {\n      if (fingerNum > 1) {\n        return;\n      }\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      if (touch.isTap.value) {\n        if (deltaTime < TAP_TIME) {\n          if (props.doubleScale) {\n            if (doubleTapTimer) {\n              clearTimeout(doubleTapTimer);\n              doubleTapTimer = null;\n              toggleScale();\n            } else {\n              doubleTapTimer = setTimeout(() => {\n                checkClose(event);\n                doubleTapTimer = null;\n              }, TAP_TIME);\n            }\n          } else {\n            checkClose(event);\n          }\n        } else if (deltaTime > LONG_PRESS_START_TIME) {\n          emit(\"longPress\");\n        }\n      }\n    };\n    const onTouchEnd = (event) => {\n      let stopPropagation = false;\n      if (state.moving || state.zooming) {\n        stopPropagation = true;\n        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {\n          stopPropagation = false;\n        }\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);\n            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);\n            state.zooming = false;\n          }\n          state.moving = false;\n          startMoveX = 0;\n          startMoveY = 0;\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          const maxZoom = +props.maxZoom;\n          if (state.scale > maxZoom) {\n            setScale(maxZoom, lastCenter);\n          }\n        }\n      }\n      preventDefault(event, stopPropagation);\n      checkTap(event);\n      touch.reset();\n    };\n    const resize = () => {\n      const {\n        rootWidth,\n        rootHeight\n      } = props;\n      const rootRatio = rootHeight / rootWidth;\n      const {\n        imageRatio\n      } = state;\n      vertical.value = state.imageRatio > rootRatio && imageRatio < longImageRatio;\n      isLongImage.value = state.imageRatio > rootRatio && imageRatio >= longImageRatio;\n      if (isLongImage.value) {\n        initialMoveY = (imageRatio * rootWidth - rootHeight) / 2;\n        state.moveY = initialMoveY;\n        state.initializing = true;\n        raf(() => {\n          state.initializing = false;\n        });\n      }\n      resetScale();\n    };\n    const onLoad = (event) => {\n      const {\n        naturalWidth,\n        naturalHeight\n      } = event.target;\n      state.imageRatio = naturalHeight / naturalWidth;\n      resize();\n    };\n    watch(() => props.active, resetScale);\n    watch(() => props.show, (value) => {\n      if (!value) {\n        resetScale();\n      }\n    });\n    watch(() => [props.rootWidth, props.rootHeight], resize);\n    useEventListener(\"touchmove\", onTouchMove, {\n      target: computed(() => {\n        var _a;\n        return (_a = swipeItem.value) == null ? void 0 : _a.$el;\n      })\n    });\n    useExpose({\n      resetScale\n    });\n    return () => {\n      const imageSlots = {\n        loading: () => _createVNode(Loading, {\n          \"type\": \"spinner\"\n        }, null)\n      };\n      return _createVNode(SwipeItem, {\n        \"ref\": swipeItem,\n        \"class\": bem(\"swipe-item\"),\n        \"onTouchstartPassive\": onTouchStart,\n        \"onTouchend\": onTouchEnd,\n        \"onTouchcancel\": onTouchEnd\n      }, {\n        default: () => [slots.image ? _createVNode(\"div\", {\n          \"class\": bem(\"image-wrap\")\n        }, [slots.image({\n          src: props.src,\n          onLoad,\n          style: imageStyle.value\n        })]) : _createVNode(Image, {\n          \"ref\": imageRef,\n          \"src\": props.src,\n          \"fit\": \"contain\",\n          \"class\": bem(\"image\", {\n            vertical: vertical.value\n          }),\n          \"style\": imageStyle.value,\n          \"onLoad\": onLoad\n        }, imageSlots)]\n      });\n    };\n  }\n});\nexport {\n  stdin_default as default\n};\n"],"mappings":"AAAA,SAASA,GAAG,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,WAAW,IAAIC,YAAY,QAAQ,KAAK;AAClG,SAASC,KAAK,EAAEC,WAAW,EAAEC,cAAc,EAAEC,eAAe,EAAEC,gBAAgB,EAAEC,qBAAqB,QAAQ,oBAAoB;AACjI,SAASC,SAAS,QAAQ,+BAA+B;AACzD,SAASC,QAAQ,QAAQ,8BAA8B;AACvD,SAASC,GAAG,EAAEC,gBAAgB,EAAEC,OAAO,QAAQ,WAAW;AAC1D,SAASC,KAAK,QAAQ,oBAAoB;AAC1C,SAASC,OAAO,QAAQ,sBAAsB;AAC9C,SAASC,SAAS,QAAQ,yBAAyB;AACnD,MAAMC,WAAW,GAAIC,OAAO,IAAKC,IAAI,CAACC,IAAI,CAAC,CAACF,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,GAAGH,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,KAAK,CAAC,GAAG,CAACH,OAAO,CAAC,CAAC,CAAC,CAACI,OAAO,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACI,OAAO,KAAK,CAAC,CAAC;AAC3I,MAAMC,SAAS,GAAIL,OAAO,KAAM;EAC9BM,CAAC,EAAE,CAACN,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,GAAGH,OAAO,CAAC,CAAC,CAAC,CAACG,OAAO,IAAI,CAAC;EAChDI,CAAC,EAAE,CAACP,OAAO,CAAC,CAAC,CAAC,CAACI,OAAO,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACI,OAAO,IAAI;AACjD,CAAC,CAAC;AACF,MAAMI,GAAG,GAAGpB,eAAe,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;AAC/C,MAAMqB,cAAc,GAAG,GAAG;AAC1B,MAAMC,qBAAqB,GAAG;EAC5BC,GAAG,EAAEC,MAAM;EACXC,IAAI,EAAEC,OAAO;EACbC,MAAM,EAAEC,MAAM;EACdC,OAAO,EAAE5B,gBAAgB,CAACH,WAAW,CAAC;EACtCgC,OAAO,EAAE7B,gBAAgB,CAACH,WAAW,CAAC;EACtCiC,SAAS,EAAE9B,gBAAgB,CAAC2B,MAAM,CAAC;EACnCI,UAAU,EAAE/B,gBAAgB,CAAC2B,MAAM,CAAC;EACpCK,WAAW,EAAEP,OAAO;EACpBQ,WAAW,EAAER,OAAO;EACpBS,iBAAiB,EAAET,OAAO;EAC1BU,mBAAmB,EAAEV,OAAO;EAC5BW,QAAQ,EAAEX;AACZ,CAAC;AACD,IAAIY,aAAa,GAAG5C,eAAe,CAAC;EAClC6C,KAAK,EAAEjB,qBAAqB;EAC5BkB,KAAK,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,CAAC;EACtCC,KAAKA,CAACF,KAAK,EAAE;IACXG,IAAI;IACJC;EACF,CAAC,EAAE;IACD,MAAMC,KAAK,GAAGnD,QAAQ,CAAC;MACrBoD,KAAK,EAAE,CAAC;MACRC,KAAK,EAAE,CAAC;MACRC,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE,KAAK;MACdC,YAAY,EAAE,KAAK;MACnBC,UAAU,EAAE;IACd,CAAC,CAAC;IACF,MAAMC,KAAK,GAAGhD,QAAQ,CAAC,CAAC;IACxB,MAAMiD,QAAQ,GAAG/D,GAAG,CAAC,CAAC;IACtB,MAAMgE,SAAS,GAAGhE,GAAG,CAAC,CAAC;IACvB,MAAM+C,QAAQ,GAAG/C,GAAG,CAAC,KAAK,CAAC;IAC3B,MAAMiE,WAAW,GAAGjE,GAAG,CAAC,KAAK,CAAC;IAC9B,IAAIkE,YAAY,GAAG,CAAC;IACpB,MAAMC,UAAU,GAAGjE,QAAQ,CAAC,MAAM;MAChC,MAAM;QACJqD,KAAK;QACLC,KAAK;QACLC,KAAK;QACLC,MAAM;QACNC,OAAO;QACPC;MACF,CAAC,GAAGN,KAAK;MACT,MAAMc,KAAK,GAAG;QACZC,kBAAkB,EAAEV,OAAO,IAAID,MAAM,IAAIE,YAAY,GAAG,IAAI,GAAG;MACjE,CAAC;MACD,IAAIL,KAAK,KAAK,CAAC,IAAIU,WAAW,CAACK,KAAK,EAAE;QACpCF,KAAK,CAACG,SAAS,GAAG,UAAUhB,KAAK,WAAWA,KAAK,KAAKC,KAAK,KAAKC,KAAK,GAAG;MAC1E;MACA,OAAOW,KAAK;IACd,CAAC,CAAC;IACF,MAAMI,QAAQ,GAAGtE,QAAQ,CAAC,MAAM;MAC9B,IAAIoD,KAAK,CAACO,UAAU,EAAE;QACpB,MAAM;UACJpB,SAAS;UACTC;QACF,CAAC,GAAGO,KAAK;QACT,MAAMwB,YAAY,GAAG1B,QAAQ,CAACuB,KAAK,GAAG5B,UAAU,GAAGY,KAAK,CAACO,UAAU,GAAGpB,SAAS;QAC/E,OAAOlB,IAAI,CAACmD,GAAG,CAAC,CAAC,EAAE,CAACpB,KAAK,CAACC,KAAK,GAAGkB,YAAY,GAAGhC,SAAS,IAAI,CAAC,CAAC;MAClE;MACA,OAAO,CAAC;IACV,CAAC,CAAC;IACF,MAAMkC,QAAQ,GAAGzE,QAAQ,CAAC,MAAM;MAC9B,IAAIoD,KAAK,CAACO,UAAU,EAAE;QACpB,MAAM;UACJpB,SAAS;UACTC;QACF,CAAC,GAAGO,KAAK;QACT,MAAM2B,aAAa,GAAG7B,QAAQ,CAACuB,KAAK,GAAG5B,UAAU,GAAGD,SAAS,GAAGa,KAAK,CAACO,UAAU;QAChF,OAAOtC,IAAI,CAACmD,GAAG,CAAC,CAAC,EAAE,CAACpB,KAAK,CAACC,KAAK,GAAGqB,aAAa,GAAGlC,UAAU,IAAI,CAAC,CAAC;MACpE;MACA,OAAO,CAAC;IACV,CAAC,CAAC;IACF,MAAMmC,QAAQ,GAAGA,CAACtB,KAAK,EAAEuB,MAAM,KAAK;MAClC,IAAIC,EAAE;MACNxB,KAAK,GAAGhD,KAAK,CAACgD,KAAK,EAAE,CAACN,KAAK,CAACV,OAAO,EAAE,CAACU,KAAK,CAACT,OAAO,GAAG,CAAC,CAAC;MACxD,IAAIe,KAAK,KAAKD,KAAK,CAACC,KAAK,EAAE;QACzB,MAAMyB,KAAK,GAAGzB,KAAK,GAAGD,KAAK,CAACC,KAAK;QACjCD,KAAK,CAACC,KAAK,GAAGA,KAAK;QACnB,IAAIuB,MAAM,EAAE;UACV,MAAMG,SAAS,GAAGhE,OAAO,CAAC,CAAC8D,EAAE,GAAGhB,QAAQ,CAACO,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGS,EAAE,CAACG,GAAG,CAAC;UAC1E,MAAMC,MAAM,GAAG;YACbvD,CAAC,EAAEqD,SAAS,CAACG,KAAK,GAAG,GAAG;YACxBvD,CAAC,EAAEoD,SAAS,CAACI,MAAM,GAAG;UACxB,CAAC;UACD,MAAM7B,KAAK,GAAGF,KAAK,CAACE,KAAK,GAAG,CAACsB,MAAM,CAAClD,CAAC,GAAGqD,SAAS,CAACK,IAAI,GAAGH,MAAM,CAACvD,CAAC,KAAKoD,KAAK,GAAG,CAAC,CAAC;UAChF,MAAMvB,KAAK,GAAGH,KAAK,CAACG,KAAK,GAAG,CAACqB,MAAM,CAACjD,CAAC,GAAGoD,SAAS,CAACM,GAAG,GAAGJ,MAAM,CAACtD,CAAC,KAAKmD,KAAK,GAAG,CAAC,CAAC;UAC/E1B,KAAK,CAACE,KAAK,GAAGjD,KAAK,CAACiD,KAAK,EAAE,CAACgB,QAAQ,CAACF,KAAK,EAAEE,QAAQ,CAACF,KAAK,CAAC;UAC3DhB,KAAK,CAACG,KAAK,GAAGlD,KAAK,CAACkD,KAAK,EAAE,CAACkB,QAAQ,CAACL,KAAK,EAAEK,QAAQ,CAACL,KAAK,CAAC;QAC7D,CAAC,MAAM;UACLhB,KAAK,CAACE,KAAK,GAAG,CAAC;UACfF,KAAK,CAACG,KAAK,GAAGQ,WAAW,CAACK,KAAK,GAAGJ,YAAY,GAAG,CAAC;QACpD;QACAd,IAAI,CAAC,OAAO,EAAE;UACZG,KAAK;UACLiC,KAAK,EAAEvC,KAAK,CAACZ;QACf,CAAC,CAAC;MACJ;IACF,CAAC;IACD,MAAMoD,UAAU,GAAGA,CAAA,KAAM;MACvBZ,QAAQ,CAAC,CAAC,CAAC;IACb,CAAC;IACD,MAAMa,WAAW,GAAGA,CAAA,KAAM;MACxB,MAAMnC,KAAK,GAAGD,KAAK,CAACC,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC;MACrCsB,QAAQ,CAACtB,KAAK,EAAEA,KAAK,KAAK,CAAC,IAAIU,WAAW,CAACK,KAAK,GAAG;QACjD1C,CAAC,EAAEkC,KAAK,CAAC6B,MAAM,CAACrB,KAAK;QACrBzC,CAAC,EAAEiC,KAAK,CAAC8B,MAAM,CAACtB;MAClB,CAAC,GAAG,KAAK,CAAC,CAAC;IACb,CAAC;IACD,IAAIuB,SAAS;IACb,IAAIC,UAAU;IACd,IAAIC,UAAU;IACd,IAAIC,UAAU;IACd,IAAIC,aAAa;IACjB,IAAIC,UAAU;IACd,IAAIC,cAAc;IAClB,IAAIC,cAAc;IAClB,IAAIC,YAAY,GAAG,KAAK;IACxB,MAAMC,YAAY,GAAIC,KAAK,IAAK;MAC9B,MAAM;QACJjF;MACF,CAAC,GAAGiF,KAAK;MACTV,SAAS,GAAGvE,OAAO,CAACkF,MAAM;MAC1B,IAAIX,SAAS,KAAK,CAAC,IAAI5C,KAAK,CAACN,WAAW,EAAE;QACxC;MACF;MACA,MAAM;QACJ8D;MACF,CAAC,GAAG3C,KAAK;MACTA,KAAK,CAAC4C,KAAK,CAACH,KAAK,CAAC;MAClBT,UAAU,GAAGxC,KAAK,CAACE,KAAK;MACxBuC,UAAU,GAAGzC,KAAK,CAACG,KAAK;MACxB2C,cAAc,GAAGO,IAAI,CAACC,GAAG,CAAC,CAAC;MAC3BP,YAAY,GAAG,KAAK;MACpB/C,KAAK,CAACI,MAAM,GAAGmC,SAAS,KAAK,CAAC,KAAKvC,KAAK,CAACC,KAAK,KAAK,CAAC,IAAIU,WAAW,CAACK,KAAK,CAAC;MAC1EhB,KAAK,CAACK,OAAO,GAAGkC,SAAS,KAAK,CAAC,IAAI,CAACY,OAAO,CAACnC,KAAK;MACjD,IAAIhB,KAAK,CAACK,OAAO,EAAE;QACjBqC,UAAU,GAAG1C,KAAK,CAACC,KAAK;QACxB0C,aAAa,GAAG5E,WAAW,CAACC,OAAO,CAAC;MACtC;IACF,CAAC;IACD,MAAMuF,WAAW,GAAIN,KAAK,IAAK;MAC7B,MAAM;QACJjF;MACF,CAAC,GAAGiF,KAAK;MACTzC,KAAK,CAACgD,IAAI,CAACP,KAAK,CAAC;MACjB,IAAIjD,KAAK,CAACI,MAAM,EAAE;QAChB,MAAM;UACJqD,MAAM;UACNC;QACF,CAAC,GAAGlD,KAAK;QACT,MAAMN,KAAK,GAAGuD,MAAM,CAACzC,KAAK,GAAGwB,UAAU;QACvC,MAAMrC,KAAK,GAAGuD,MAAM,CAAC1C,KAAK,GAAGyB,UAAU;QACvC,IAAI,CAAC9C,KAAK,CAACF,QAAQ,GAAGe,KAAK,CAACmD,UAAU,CAAC,CAAC,IAAI1F,IAAI,CAAC2F,GAAG,CAACzD,KAAK,CAAC,GAAGkB,QAAQ,CAACL,KAAK,GAAGR,KAAK,CAACqD,YAAY,CAAC,CAAC,IAAI5F,IAAI,CAAC2F,GAAG,CAAC1D,KAAK,CAAC,GAAGgB,QAAQ,CAACF,KAAK,KAAK,CAAC+B,YAAY,EAAE;UACzJ/C,KAAK,CAACI,MAAM,GAAG,KAAK;UACpB;QACF;QACA2C,YAAY,GAAG,IAAI;QACnB5F,cAAc,CAAC8F,KAAK,EAAE,IAAI,CAAC;QAC3BjD,KAAK,CAACE,KAAK,GAAGjD,KAAK,CAACiD,KAAK,EAAE,CAACgB,QAAQ,CAACF,KAAK,EAAEE,QAAQ,CAACF,KAAK,CAAC;QAC3DhB,KAAK,CAACG,KAAK,GAAGlD,KAAK,CAACkD,KAAK,EAAE,CAACkB,QAAQ,CAACL,KAAK,EAAEK,QAAQ,CAACL,KAAK,CAAC;MAC7D;MACA,IAAIhB,KAAK,CAACK,OAAO,EAAE;QACjBlD,cAAc,CAAC8F,KAAK,EAAE,IAAI,CAAC;QAC3B,IAAIjF,OAAO,CAACkF,MAAM,KAAK,CAAC,EAAE;UACxB,MAAMY,QAAQ,GAAG/F,WAAW,CAACC,OAAO,CAAC;UACrC,MAAMiC,KAAK,GAAGyC,UAAU,GAAGoB,QAAQ,GAAGnB,aAAa;UACnDC,UAAU,GAAGvE,SAAS,CAACL,OAAO,CAAC;UAC/BuD,QAAQ,CAACtB,KAAK,EAAE2C,UAAU,CAAC;QAC7B;MACF;IACF,CAAC;IACD,MAAMmB,UAAU,GAAId,KAAK,IAAK;MAC5B,IAAIxB,EAAE;MACN,MAAMuC,WAAW,GAAG,CAACvC,EAAE,GAAGf,SAAS,CAACM,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGS,EAAE,CAACG,GAAG;MACpE,IAAI,CAACoC,WAAW,EAAE;MAClB,MAAMC,OAAO,GAAGD,WAAW,CAACE,iBAAiB;MAC7C,MAAMC,cAAc,GAAGlB,KAAK,CAACmB,MAAM,KAAKJ,WAAW;MACnD,MAAMK,YAAY,GAAGJ,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACK,QAAQ,CAACrB,KAAK,CAACmB,MAAM,CAAC;MAC9E,IAAI,CAACzE,KAAK,CAACJ,iBAAiB,IAAI8E,YAAY,EAAE;MAC9C,IAAI,CAAC1E,KAAK,CAACH,mBAAmB,IAAI2E,cAAc,EAAE;MAClDrE,IAAI,CAAC,OAAO,CAAC;IACf,CAAC;IACD,MAAMyE,QAAQ,GAAItB,KAAK,IAAK;MAC1B,IAAIV,SAAS,GAAG,CAAC,EAAE;QACjB;MACF;MACA,MAAMiC,SAAS,GAAGnB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGR,cAAc;MAC7C,MAAM2B,QAAQ,GAAG,GAAG;MACpB,IAAIjE,KAAK,CAACkE,KAAK,CAAC1D,KAAK,EAAE;QACrB,IAAIwD,SAAS,GAAGC,QAAQ,EAAE;UACxB,IAAI9E,KAAK,CAACL,WAAW,EAAE;YACrB,IAAIuD,cAAc,EAAE;cAClB8B,YAAY,CAAC9B,cAAc,CAAC;cAC5BA,cAAc,GAAG,IAAI;cACrBT,WAAW,CAAC,CAAC;YACf,CAAC,MAAM;cACLS,cAAc,GAAG+B,UAAU,CAAC,MAAM;gBAChCb,UAAU,CAACd,KAAK,CAAC;gBACjBJ,cAAc,GAAG,IAAI;cACvB,CAAC,EAAE4B,QAAQ,CAAC;YACd;UACF,CAAC,MAAM;YACLV,UAAU,CAACd,KAAK,CAAC;UACnB;QACF,CAAC,MAAM,IAAIuB,SAAS,GAAGlH,qBAAqB,EAAE;UAC5CwC,IAAI,CAAC,WAAW,CAAC;QACnB;MACF;IACF,CAAC;IACD,MAAM+E,UAAU,GAAI5B,KAAK,IAAK;MAC5B,IAAI6B,eAAe,GAAG,KAAK;MAC3B,IAAI9E,KAAK,CAACI,MAAM,IAAIJ,KAAK,CAACK,OAAO,EAAE;QACjCyE,eAAe,GAAG,IAAI;QACtB,IAAI9E,KAAK,CAACI,MAAM,IAAIoC,UAAU,KAAKxC,KAAK,CAACE,KAAK,IAAIuC,UAAU,KAAKzC,KAAK,CAACG,KAAK,EAAE;UAC5E2E,eAAe,GAAG,KAAK;QACzB;QACA,IAAI,CAAC7B,KAAK,CAACjF,OAAO,CAACkF,MAAM,EAAE;UACzB,IAAIlD,KAAK,CAACK,OAAO,EAAE;YACjBL,KAAK,CAACE,KAAK,GAAGjD,KAAK,CAAC+C,KAAK,CAACE,KAAK,EAAE,CAACgB,QAAQ,CAACF,KAAK,EAAEE,QAAQ,CAACF,KAAK,CAAC;YACjEhB,KAAK,CAACG,KAAK,GAAGlD,KAAK,CAAC+C,KAAK,CAACG,KAAK,EAAE,CAACkB,QAAQ,CAACL,KAAK,EAAEK,QAAQ,CAACL,KAAK,CAAC;YACjEhB,KAAK,CAACK,OAAO,GAAG,KAAK;UACvB;UACAL,KAAK,CAACI,MAAM,GAAG,KAAK;UACpBoC,UAAU,GAAG,CAAC;UACdC,UAAU,GAAG,CAAC;UACdC,UAAU,GAAG,CAAC;UACd,IAAI1C,KAAK,CAACC,KAAK,GAAG,CAAC,EAAE;YACnBkC,UAAU,CAAC,CAAC;UACd;UACA,MAAMjD,OAAO,GAAG,CAACS,KAAK,CAACT,OAAO;UAC9B,IAAIc,KAAK,CAACC,KAAK,GAAGf,OAAO,EAAE;YACzBqC,QAAQ,CAACrC,OAAO,EAAE0D,UAAU,CAAC;UAC/B;QACF;MACF;MACAzF,cAAc,CAAC8F,KAAK,EAAE6B,eAAe,CAAC;MACtCP,QAAQ,CAACtB,KAAK,CAAC;MACfzC,KAAK,CAACuE,KAAK,CAAC,CAAC;IACf,CAAC;IACD,MAAMC,MAAM,GAAGA,CAAA,KAAM;MACnB,MAAM;QACJ7F,SAAS;QACTC;MACF,CAAC,GAAGO,KAAK;MACT,MAAMsF,SAAS,GAAG7F,UAAU,GAAGD,SAAS;MACxC,MAAM;QACJoB;MACF,CAAC,GAAGP,KAAK;MACTP,QAAQ,CAACuB,KAAK,GAAGhB,KAAK,CAACO,UAAU,GAAG0E,SAAS,IAAI1E,UAAU,GAAG9B,cAAc;MAC5EkC,WAAW,CAACK,KAAK,GAAGhB,KAAK,CAACO,UAAU,GAAG0E,SAAS,IAAI1E,UAAU,IAAI9B,cAAc;MAChF,IAAIkC,WAAW,CAACK,KAAK,EAAE;QACrBJ,YAAY,GAAG,CAACL,UAAU,GAAGpB,SAAS,GAAGC,UAAU,IAAI,CAAC;QACxDY,KAAK,CAACG,KAAK,GAAGS,YAAY;QAC1BZ,KAAK,CAACM,YAAY,GAAG,IAAI;QACzB7C,GAAG,CAAC,MAAM;UACRuC,KAAK,CAACM,YAAY,GAAG,KAAK;QAC5B,CAAC,CAAC;MACJ;MACA6B,UAAU,CAAC,CAAC;IACd,CAAC;IACD,MAAM+C,MAAM,GAAIjC,KAAK,IAAK;MACxB,MAAM;QACJkC,YAAY;QACZC;MACF,CAAC,GAAGnC,KAAK,CAACmB,MAAM;MAChBpE,KAAK,CAACO,UAAU,GAAG6E,aAAa,GAAGD,YAAY;MAC/CH,MAAM,CAAC,CAAC;IACV,CAAC;IACDrI,KAAK,CAAC,MAAMgD,KAAK,CAACZ,MAAM,EAAEoD,UAAU,CAAC;IACrCxF,KAAK,CAAC,MAAMgD,KAAK,CAACd,IAAI,EAAGmC,KAAK,IAAK;MACjC,IAAI,CAACA,KAAK,EAAE;QACVmB,UAAU,CAAC,CAAC;MACd;IACF,CAAC,CAAC;IACFxF,KAAK,CAAC,MAAM,CAACgD,KAAK,CAACR,SAAS,EAAEQ,KAAK,CAACP,UAAU,CAAC,EAAE4F,MAAM,CAAC;IACxDtH,gBAAgB,CAAC,WAAW,EAAE6F,WAAW,EAAE;MACzCa,MAAM,EAAExH,QAAQ,CAAC,MAAM;QACrB,IAAI6E,EAAE;QACN,OAAO,CAACA,EAAE,GAAGf,SAAS,CAACM,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGS,EAAE,CAACG,GAAG;MACzD,CAAC;IACH,CAAC,CAAC;IACFrE,SAAS,CAAC;MACR4E;IACF,CAAC,CAAC;IACF,OAAO,MAAM;MACX,MAAMkD,UAAU,GAAG;QACjBC,OAAO,EAAEA,CAAA,KAAMtI,YAAY,CAACa,OAAO,EAAE;UACnC,MAAM,EAAE;QACV,CAAC,EAAE,IAAI;MACT,CAAC;MACD,OAAOb,YAAY,CAACc,SAAS,EAAE;QAC7B,KAAK,EAAE4C,SAAS;QAChB,OAAO,EAAElC,GAAG,CAAC,YAAY,CAAC;QAC1B,qBAAqB,EAAEwE,YAAY;QACnC,YAAY,EAAE6B,UAAU;QACxB,eAAe,EAAEA;MACnB,CAAC,EAAE;QACDU,OAAO,EAAEA,CAAA,KAAM,CAACxF,KAAK,CAACyF,KAAK,GAAGxI,YAAY,CAAC,KAAK,EAAE;UAChD,OAAO,EAAEwB,GAAG,CAAC,YAAY;QAC3B,CAAC,EAAE,CAACuB,KAAK,CAACyF,KAAK,CAAC;UACd7G,GAAG,EAAEgB,KAAK,CAAChB,GAAG;UACduG,MAAM;UACNpE,KAAK,EAAED,UAAU,CAACG;QACpB,CAAC,CAAC,CAAC,CAAC,GAAGhE,YAAY,CAACY,KAAK,EAAE;UACzB,KAAK,EAAE6C,QAAQ;UACf,KAAK,EAAEd,KAAK,CAAChB,GAAG;UAChB,KAAK,EAAE,SAAS;UAChB,OAAO,EAAEH,GAAG,CAAC,OAAO,EAAE;YACpBiB,QAAQ,EAAEA,QAAQ,CAACuB;UACrB,CAAC,CAAC;UACF,OAAO,EAAEH,UAAU,CAACG,KAAK;UACzB,QAAQ,EAAEkE;QACZ,CAAC,EAAEG,UAAU,CAAC;MAChB,CAAC,CAAC;IACJ,CAAC;EACH;AACF,CAAC,CAAC;AACF,SACE3F,aAAa,IAAI6F,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { ref, onMounted, watch, onUnmounted } from 'vue';\nimport { useRoute, useRouter } from 'vue-router';\nimport { Toast } from 'vant';\nimport axios from 'axios';\nexport default {\n  name: 'PaymentPage',\n  setup() {\n    const route = useRoute();\n    const router = useRouter();\n\n    // 从路由参数获取订单信息\n    const gender = route.query.gender;\n    const calendarType = route.query.calendarType;\n    const birthDate = route.query.birthDate;\n    const birthTime = route.query.birthTime;\n    const birthPlace = route.query.birthPlace;\n    const livingPlace = route.query.livingPlace;\n    const focusAreas = route.query.focusAreas?.split(',') || [];\n\n    // 支付相关状态\n    const orderId = ref('');\n    const createTime = ref(new Date().toLocaleString());\n    const paymentMethod = ref('wechat');\n    const showQRCode = ref(false);\n    const qrCodeUrl = ref('');\n    const isProcessing = ref(false);\n    onMounted(async () => {\n      // 调用API创建订单\n      try {\n        Toast.loading({\n          message: '正在创建订单...',\n          duration: 0,\n          forbidClick: true\n        });\n\n        // 调用订单创建API\n        const response = await axios.post('/api/order/create/simple', {\n          gender,\n          birthDate,\n          birthTime,\n          birthPlace,\n          livingPlace,\n          focusAreas: focusAreas || [],\n          calendarType: calendarType || 'solar'\n        });\n        if (response.data.code === 200) {\n          orderId.value = response.data.data.orderId;\n          createTime.value = new Date().toLocaleString();\n          Toast.success('订单创建成功');\n          console.log('订单创建成功', orderId.value);\n        } else {\n          Toast.fail(response.data.message || '创建订单失败');\n        }\n      } catch (error) {\n        console.error('创建订单失败:', error);\n        Toast.fail('创建订单失败，请重试');\n      }\n    });\n    const onClickLeft = () => {\n      router.go(-1);\n    };\n    const onPayment = () => {\n      // 检查订单ID\n      if (!orderId.value) {\n        Toast.fail('订单尚未创建，请刷新页面重试');\n        return;\n      }\n\n      // 根据支付方式获取真实二维码\n      Toast.loading({\n        message: '正在获取支付二维码...',\n        duration: 0,\n        forbidClick: true\n      });\n\n      // 创建真实支付订单并获取支付二维码\n      const createPayment = async () => {\n        try {\n          const paymentData = {\n            paymentMethod: paymentMethod.value,\n            birthDate,\n            birthTime,\n            gender,\n            focusAreas,\n            calendarType,\n            birthPlace,\n            livingPlace\n          };\n\n          // 调用真实支付API\n          const response = await axios.post(`/api/order/create/payment/${orderId.value}`, paymentData);\n          if (response.data.code === 200) {\n            Toast.clear();\n\n            // 解析支付二维码返回数据\n            if (response.data.data.qr_image) {\n              // 直接使用Base64二维码图片\n              qrCodeUrl.value = response.data.data.qr_image;\n              showQRCode.value = true;\n            } else if (response.data.data.code_url) {\n              // 生成二维码图片\n              qrCodeUrl.value = response.data.data.code_url;\n              showQRCode.value = true;\n            } else if (response.data.data.pay_url) {\n              // 支付宝URL\n              window.open(response.data.data.pay_url, '_blank');\n            } else {\n              Toast.fail('未获取到支付二维码');\n            }\n          } else {\n            Toast.fail(response.data.message || '获取支付二维码失败');\n          }\n        } catch (error) {\n          console.error('获取支付二维码出错:', error);\n          Toast.fail('获取支付二维码失败');\n        }\n      };\n      createPayment();\n    };\n    const onPaymentSuccess = async () => {\n      if (isProcessing.value) {\n        return false;\n      }\n      isProcessing.value = true;\n      Toast.loading({\n        message: '正在查询支付结果...',\n        duration: 0,\n        forbidClick: true\n      });\n      try {\n        // 查询支付结果API\n        console.log('查询支付结果:', orderId.value);\n\n        // 增加重试次数，微信支付状态更新可能有延迟\n        let retryCount = 0;\n        const maxRetries = 3;\n        let response;\n        let paymentSuccess = false;\n\n        // 重试查询支付状态\n        while (retryCount < maxRetries && !paymentSuccess) {\n          response = await axios.get(`/api/order/query/${orderId.value}`);\n          console.log(`支付查询响应 (尝试 ${retryCount + 1}/${maxRetries}):`, response.data);\n          if (response.data.code === 200 && response.data.data.status === 'paid') {\n            paymentSuccess = true;\n            break;\n          }\n\n          // 如果查询失败，等待2秒后重试\n          if (!paymentSuccess) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            retryCount++;\n          }\n        }\n\n        // 如果重试后仍未成功，尝试手动更新接口\n        if (!paymentSuccess) {\n          console.log('查询支付状态失败，尝试手动更新订单状态');\n          response = await axios.get(`/api/order/manual_update/${orderId.value}`);\n          console.log('手动更新响应:', response.data);\n          paymentSuccess = response.data.code === 200 && response.data.data.status === 'paid';\n        }\n        if (paymentSuccess) {\n          Toast.success('支付成功');\n          showQRCode.value = false;\n\n          // 使用服务器返回的resultId\n          const resultId = response.data.data.resultId;\n          if (!resultId) {\n            console.error('服务器未返回有效的resultId');\n            // 生成默认结果ID并尝试手动更新\n            const defaultResultId = 'RES' + orderId.value.replace(/^BZ/, '');\n            console.log('使用默认结果ID:', defaultResultId);\n            try {\n              // 尝试手动更新获取结果ID\n              const manualResponse = await axios.get(`/api/order/manual_update/${orderId.value}`);\n              console.log('手动更新响应:', manualResponse.data);\n              if (manualResponse.data.code === 200 && manualResponse.data.data.resultId) {\n                // 使用手动更新返回的resultId\n                const updatedResultId = manualResponse.data.data.resultId;\n                console.log('手动更新成功，获取到结果ID:', updatedResultId);\n\n                // 继续处理计算和分析\n                await processBaziCalculation(updatedResultId);\n\n                // 跳转到结果页面\n                redirectToResultPage(updatedResultId);\n                return;\n              } else {\n                Toast.fail('无法获取有效的结果ID，将使用默认ID');\n                await processBaziCalculation(defaultResultId);\n                redirectToResultPage(defaultResultId);\n                return;\n              }\n            } catch (manualError) {\n              console.error('手动更新失败:', manualError);\n              Toast.fail('获取结果ID失败，使用默认ID');\n              await processBaziCalculation(defaultResultId);\n              redirectToResultPage(defaultResultId);\n              return;\n            }\n          }\n          console.log('获取到结果ID:', resultId);\n\n          // 请求立即计算完整的命盘数据\n          await processBaziCalculation(resultId);\n\n          // 跳转到结果页面\n          redirectToResultPage(resultId);\n        } else {\n          Toast.fail(response?.data?.message || '支付处理失败');\n          isProcessing.value = false;\n        }\n      } catch (error) {\n        console.error('支付处理出错:', error);\n\n        // 错误处理：尝试构造默认结果ID\n        Toast.clear();\n        Toast.fail('支付处理出错，将使用默认结果ID');\n\n        // 构造默认结果ID\n        const defaultResultId = 'RES' + orderId.value.replace(/^BZ/, '');\n        console.log('使用默认结果ID:', defaultResultId);\n\n        // 尝试计算和跳转\n        await processBaziCalculation(defaultResultId);\n\n        // 即使出错也跳转到结果页面，使用默认结果ID\n        redirectToResultPage(defaultResultId);\n      } finally {\n        isProcessing.value = false;\n      }\n    };\n\n    // 提取八字计算过程为独立函数\n    const processBaziCalculation = async resultId => {\n      try {\n        Toast.loading({\n          message: '正在生成八字命盘...',\n          duration: 0,\n          forbidClick: true\n        });\n\n        // 获取基础URL，确保在不同环境下都能正确请求API\n        const baseUrl = process.env.VUE_APP_API_URL || window.location.origin;\n        console.log('使用API基础URL:', baseUrl);\n\n        // 添加重试机制\n        let retryCount = 0;\n        const maxRetries = 3;\n        let updateSuccess = false;\n        while (retryCount < maxRetries && !updateSuccess) {\n          try {\n            // 修改：使用正确的update API端点\n            console.log(`正在请求更新八字数据 (尝试 ${retryCount + 1}/${maxRetries}):`, resultId);\n            const updateResponse = await axios.post(`${baseUrl}/api/bazi/update/${resultId}`, {\n              birthDate,\n              birthTime,\n              gender,\n              calendarType,\n              birthPlace,\n              livingPlace,\n              focusAreas,\n              forceRecalculate: true,\n              // 强制重新计算基础数据\n              generateShenshaData: true,\n              // 生成神煞数据\n              generateDayunData: true,\n              // 生成大运数据 \n              generateLiunianData: true,\n              // 生成流年数据\n              useDeepseekAPI: true // 使用DeepSeek API进行分析\n            });\n            console.log('八字数据更新响应:', updateResponse.data);\n            if (updateResponse.data.code === 200) {\n              updateSuccess = true;\n              Toast.success('命盘数据生成中');\n\n              // 确保延迟足够长，以便后端完成八字数据处理\n              setTimeout(async () => {\n                try {\n                  console.log('正在请求八字深度分析:', resultId);\n                  const analyzeResponse = await axios.post(`${baseUrl}/api/bazi/analyze/${resultId}`, {\n                    useDeepseekAPI: true\n                  });\n                  console.log('八字深度分析响应:', analyzeResponse.data);\n                  Toast.success('命盘分析已开始');\n                } catch (analyzeError) {\n                  console.error('深度分析请求失败:', analyzeError);\n                  // 即使分析请求失败，也继续流程，不阻止用户查看结果\n                  Toast.fail('命盘深度分析请求失败，但可以继续查看基础结果');\n                }\n              }, 3000); // 延长等待时间到3秒\n\n              break; // 成功后跳出循环\n            } else {\n              console.error('八字数据更新失败:', updateResponse.data.message);\n              // 失败后重试\n              await new Promise(resolve => setTimeout(resolve, 1000));\n              retryCount++;\n            }\n          } catch (error) {\n            console.error(`更新请求失败 (尝试 ${retryCount + 1}/${maxRetries}):`, error);\n\n            // 如果是404错误，可能是结果记录还未创建，尝试手动更新订单状态\n            if (error.response && error.response.status === 404) {\n              console.log('结果记录不存在，尝试手动更新订单状态');\n              try {\n                const manualResponse = await axios.get(`${baseUrl}/api/order/manual_update/${orderId.value}`);\n                console.log('手动更新响应:', manualResponse.data);\n                if (manualResponse.data.code === 200 && manualResponse.data.data.resultId) {\n                  // 使用手动更新返回的resultId\n                  const updatedResultId = manualResponse.data.data.resultId;\n                  console.log('手动更新成功，获取到新的结果ID:', updatedResultId);\n\n                  // 更新当前使用的resultId\n                  resultId = updatedResultId;\n                }\n              } catch (manualError) {\n                console.error('手动更新失败:', manualError);\n              }\n            }\n\n            // 失败后重试\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            retryCount++;\n          }\n        }\n        if (!updateSuccess) {\n          Toast.fail('命盘计算请求失败，请稍后在结果页面刷新重试');\n          console.error('达到最大重试次数，八字数据更新失败');\n        }\n      } catch (calcError) {\n        console.error('命盘计算请求失败:', calcError);\n        Toast.fail('命盘计算请求失败，但您仍可以查看结果页面');\n      }\n    };\n\n    // 添加结果页面跳转函数\n    const redirectToResultPage = resultId => {\n      // 延迟跳转，给用户体验更好的过渡\n      setTimeout(() => {\n        router.push({\n          path: `/result/${resultId}`,\n          query: {\n            birthDate,\n            birthTime,\n            gender,\n            birthPlace,\n            livingPlace,\n            originalOrderId: orderId.value // 传递原始订单ID\n          }\n        });\n      }, 1000);\n    };\n    const checkPaymentStatus = async () => {\n      if (isProcessing.value) return;\n      isProcessing.value = true;\n      Toast.loading({\n        message: '正在查询支付状态...',\n        duration: 0,\n        forbidClick: true\n      });\n      try {\n        const response = await axios.get(`/api/order/query/${orderId.value}`);\n        console.log('支付状态查询响应:', response.data);\n        if (response.data.code === 200 && response.data.data.status === 'paid') {\n          // 支付成功，继续处理\n          onPaymentSuccess();\n        } else {\n          Toast.fail('未检测到支付完成，请确认支付或稍后再试');\n          isProcessing.value = false;\n        }\n      } catch (error) {\n        console.error('查询支付状态失败:', error);\n        Toast.fail('查询支付状态失败');\n        isProcessing.value = false;\n      }\n    };\n\n    // 添加轮询支付状态的方法\n    let paymentStatusInterval = null;\n    const startPaymentStatusPolling = () => {\n      // 每5秒查询一次支付状态\n      paymentStatusInterval = setInterval(async () => {\n        try {\n          const response = await axios.get(`/api/order/query/${orderId.value}`);\n          console.log('轮询支付状态:', response.data);\n          if (response.data.code === 200 && response.data.data.status === 'paid') {\n            // 支付成功，停止轮询并处理\n            clearInterval(paymentStatusInterval);\n            onPaymentSuccess();\n          }\n        } catch (error) {\n          console.error('轮询支付状态失败:', error);\n        }\n      }, 5000);\n    };\n\n    // 在显示二维码时开始轮询，在组件销毁时清除轮询\n    watch(showQRCode, newVal => {\n      if (newVal) {\n        startPaymentStatusPolling();\n      } else if (paymentStatusInterval) {\n        clearInterval(paymentStatusInterval);\n      }\n    });\n    onUnmounted(() => {\n      if (paymentStatusInterval) {\n        clearInterval(paymentStatusInterval);\n      }\n    });\n    return {\n      orderId,\n      createTime,\n      paymentMethod,\n      showQRCode,\n      qrCodeUrl,\n      isProcessing,\n      onClickLeft,\n      onPayment,\n      onPaymentSuccess,\n      checkPaymentStatus\n    };\n  }\n};","map":{"version":3,"names":["ref","onMounted","watch","onUnmounted","useRoute","useRouter","Toast","axios","name","setup","route","router","gender","query","calendarType","birthDate","birthTime","birthPlace","livingPlace","focusAreas","split","orderId","createTime","Date","toLocaleString","paymentMethod","showQRCode","qrCodeUrl","isProcessing","loading","message","duration","forbidClick","response","post","data","code","value","success","console","log","fail","error","onClickLeft","go","onPayment","createPayment","paymentData","clear","qr_image","code_url","pay_url","window","open","onPaymentSuccess","retryCount","maxRetries","paymentSuccess","get","status","Promise","resolve","setTimeout","resultId","defaultResultId","replace","manualResponse","updatedResultId","processBaziCalculation","redirectToResultPage","manualError","baseUrl","process","env","VUE_APP_API_URL","location","origin","updateSuccess","updateResponse","forceRecalculate","generateShenshaData","generateDayunData","generateLiunianData","useDeepseekAPI","analyzeResponse","analyzeError","calcError","push","path","originalOrderId","checkPaymentStatus","paymentStatusInterval","startPaymentStatusPolling","setInterval","clearInterval","newVal"],"sources":["D:\\Python\\20250603开发八字命理AI指导功能页码\\开发八字命理AI指导功能页码\\frontend\\src\\Payment.vue"],"sourcesContent":["<template>\n  <div class=\"payment-container\">\n    <van-nav-bar\n      title=\"订单支付\"\n      left-text=\"返回\"\n      left-arrow\n      @click-left=\"onClickLeft\"\n    />\n    \n    <van-card\n      title=\"八字命理AI人生指导\"\n      desc=\"个性化人生指导建议\"\n      price=\"9.90\"\n      currency=\"¥\"\n    >\n      <template #tags>\n        <van-tag plain type=\"primary\">专业分析</van-tag>\n        <van-tag plain type=\"success\">AI解读</van-tag>\n        <van-tag plain type=\"warning\">PDF报告</van-tag>\n      </template>\n    </van-card>\n    \n    <van-cell-group inset title=\"订单信息\">\n      <van-cell title=\"订单编号\" :value=\"orderId\" />\n      <van-cell title=\"创建时间\" :value=\"createTime\" />\n      <van-cell title=\"支付金额\" value=\"¥9.90\" />\n    </van-cell-group>\n    \n    <van-cell-group inset title=\"选择支付方式\">\n      <van-cell clickable @click=\"paymentMethod = 'wechat'\">\n        <template #title>\n          <div class=\"payment-method\">\n            <van-icon name=\"wechat\" color=\"#07C160\" size=\"24\" />\n            <span class=\"payment-name\">微信支付</span>\n          </div>\n        </template>\n        <template #right-icon>\n          <van-radio :name=\"'wechat'\" :checked=\"paymentMethod === 'wechat'\" />\n        </template>\n      </van-cell>\n      \n      <van-cell clickable @click=\"paymentMethod = 'alipay'\">\n        <template #title>\n          <div class=\"payment-method\">\n            <van-icon name=\"alipay\" color=\"#1677FF\" size=\"24\" />\n            <span class=\"payment-name\">支付宝</span>\n          </div>\n        </template>\n        <template #right-icon>\n          <van-radio :name=\"'alipay'\" :checked=\"paymentMethod === 'alipay'\" />\n        </template>\n      </van-cell>\n    </van-cell-group>\n    \n    <div class=\"payment-action\">\n      <van-button round block type=\"primary\" @click=\"onPayment\">\n        立即支付\n      </van-button>\n    </div>\n    \n    <van-popup :show=\"showQRCode\" @update:show=\"showQRCode = $event\" round>\n      <div class=\"qrcode-container\">\n        <h3>请扫码支付</h3>\n        <div class=\"qrcode\">\n          <img v-if=\"qrCodeUrl && qrCodeUrl.startsWith('data:')\" :src=\"qrCodeUrl\" alt=\"支付二维码\" />\n          <iframe v-else-if=\"qrCodeUrl\" :src=\"qrCodeUrl\" frameborder=\"0\" width=\"200\" height=\"200\"></iframe>\n          <div v-else class=\"qrcode-placeholder\">\n            <p>正在加载支付二维码...</p>\n          </div>\n        </div>\n        <p>支付金额: ¥9.90</p>\n        <van-button type=\"primary\" block @click=\"checkPaymentStatus\">\n          我已完成支付\n        </van-button>\n        <van-button plain block @click=\"showQRCode = false\" style=\"margin-top: 10px\">\n          取消\n        </van-button>\n      </div>\n    </van-popup>\n  </div>\n</template>\n\n<script>\nimport { ref, onMounted, watch, onUnmounted } from 'vue';\nimport { useRoute, useRouter } from 'vue-router';\nimport { Toast } from 'vant';\nimport axios from 'axios';\n\nexport default {\n  name: 'PaymentPage',\n  setup() {\n    const route = useRoute();\n    const router = useRouter();\n    \n    // 从路由参数获取订单信息\n    const gender = route.query.gender;\n    const calendarType = route.query.calendarType;\n    const birthDate = route.query.birthDate;\n    const birthTime = route.query.birthTime;\n    const birthPlace = route.query.birthPlace;\n    const livingPlace = route.query.livingPlace;\n    const focusAreas = route.query.focusAreas?.split(',') || [];\n    \n    // 支付相关状态\n    const orderId = ref('');\n    const createTime = ref(new Date().toLocaleString());\n    const paymentMethod = ref('wechat');\n    const showQRCode = ref(false);\n    const qrCodeUrl = ref('');\n    const isProcessing = ref(false);\n    \n    onMounted(async () => {\n      // 调用API创建订单\n      try {\n        Toast.loading({\n          message: '正在创建订单...',\n          duration: 0,\n          forbidClick: true\n        });\n        \n        // 调用订单创建API\n        const response = await axios.post('/api/order/create/simple', {\n          gender,\n          birthDate,\n          birthTime,\n          birthPlace,\n          livingPlace,\n          focusAreas: focusAreas || [],\n          calendarType: calendarType || 'solar'\n        });\n        \n        if (response.data.code === 200) {\n          orderId.value = response.data.data.orderId;\n          createTime.value = new Date().toLocaleString();\n          Toast.success('订单创建成功');\n          console.log('订单创建成功', orderId.value);\n        } else {\n          Toast.fail(response.data.message || '创建订单失败');\n        }\n      } catch (error) {\n        console.error('创建订单失败:', error);\n        Toast.fail('创建订单失败，请重试');\n      }\n    });\n    \n    const onClickLeft = () => {\n      router.go(-1);\n    };\n    \n    const onPayment = () => {\n      // 检查订单ID\n      if (!orderId.value) {\n        Toast.fail('订单尚未创建，请刷新页面重试');\n        return;\n      }\n      \n      // 根据支付方式获取真实二维码\n      Toast.loading({\n        message: '正在获取支付二维码...',\n        duration: 0,\n        forbidClick: true\n      });\n      \n      // 创建真实支付订单并获取支付二维码\n      const createPayment = async () => {\n        try {\n          const paymentData = {\n            paymentMethod: paymentMethod.value,\n            birthDate,\n            birthTime,\n            gender,\n            focusAreas,\n            calendarType,\n            birthPlace,\n            livingPlace\n          };\n          \n          // 调用真实支付API\n          const response = await axios.post(`/api/order/create/payment/${orderId.value}`, paymentData);\n          \n          if (response.data.code === 200) {\n            Toast.clear();\n            \n            // 解析支付二维码返回数据\n            if (response.data.data.qr_image) {\n              // 直接使用Base64二维码图片\n              qrCodeUrl.value = response.data.data.qr_image;\n              showQRCode.value = true;\n            } else if (response.data.data.code_url) {\n              // 生成二维码图片\n              qrCodeUrl.value = response.data.data.code_url;\n              showQRCode.value = true;\n            } else if (response.data.data.pay_url) {\n              // 支付宝URL\n              window.open(response.data.data.pay_url, '_blank');\n            } else {\n              Toast.fail('未获取到支付二维码');\n            }\n          } else {\n            Toast.fail(response.data.message || '获取支付二维码失败');\n          }\n        } catch (error) {\n          console.error('获取支付二维码出错:', error);\n          Toast.fail('获取支付二维码失败');\n        }\n      };\n      \n      createPayment();\n    };\n    \n    const onPaymentSuccess = async () => {\n      if (isProcessing.value) {\n        return false;\n      }\n      \n      isProcessing.value = true;\n      Toast.loading({\n        message: '正在查询支付结果...',\n        duration: 0,\n        forbidClick: true\n      });\n      \n      try {\n        // 查询支付结果API\n        console.log('查询支付结果:', orderId.value);\n        \n        // 增加重试次数，微信支付状态更新可能有延迟\n        let retryCount = 0;\n        const maxRetries = 3;\n        let response;\n        let paymentSuccess = false;\n        \n        // 重试查询支付状态\n        while (retryCount < maxRetries && !paymentSuccess) {\n          response = await axios.get(`/api/order/query/${orderId.value}`);\n          console.log(`支付查询响应 (尝试 ${retryCount + 1}/${maxRetries}):`, response.data);\n          \n          if (response.data.code === 200 && response.data.data.status === 'paid') {\n            paymentSuccess = true;\n            break;\n          }\n          \n          // 如果查询失败，等待2秒后重试\n          if (!paymentSuccess) {\n            await new Promise(resolve => setTimeout(resolve, 2000));\n            retryCount++;\n          }\n        }\n        \n        // 如果重试后仍未成功，尝试手动更新接口\n        if (!paymentSuccess) {\n          console.log('查询支付状态失败，尝试手动更新订单状态');\n          response = await axios.get(`/api/order/manual_update/${orderId.value}`);\n          console.log('手动更新响应:', response.data);\n          paymentSuccess = (response.data.code === 200 && response.data.data.status === 'paid');\n        }\n        \n        if (paymentSuccess) {\n          Toast.success('支付成功');\n          showQRCode.value = false;\n          \n          // 使用服务器返回的resultId\n          const resultId = response.data.data.resultId;\n          \n          if (!resultId) {\n            console.error('服务器未返回有效的resultId');\n            // 生成默认结果ID并尝试手动更新\n            const defaultResultId = 'RES' + orderId.value.replace(/^BZ/, '');\n            console.log('使用默认结果ID:', defaultResultId);\n            \n            try {\n              // 尝试手动更新获取结果ID\n              const manualResponse = await axios.get(`/api/order/manual_update/${orderId.value}`);\n              console.log('手动更新响应:', manualResponse.data);\n              \n              if (manualResponse.data.code === 200 && manualResponse.data.data.resultId) {\n                // 使用手动更新返回的resultId\n                const updatedResultId = manualResponse.data.data.resultId;\n                console.log('手动更新成功，获取到结果ID:', updatedResultId);\n                \n                // 继续处理计算和分析\n                await processBaziCalculation(updatedResultId);\n                \n                // 跳转到结果页面\n                redirectToResultPage(updatedResultId);\n                return;\n              } else {\n                Toast.fail('无法获取有效的结果ID，将使用默认ID');\n                await processBaziCalculation(defaultResultId);\n                redirectToResultPage(defaultResultId);\n                return;\n              }\n            } catch (manualError) {\n              console.error('手动更新失败:', manualError);\n              Toast.fail('获取结果ID失败，使用默认ID');\n              await processBaziCalculation(defaultResultId);\n              redirectToResultPage(defaultResultId);\n              return;\n            }\n          }\n          \n          console.log('获取到结果ID:', resultId);\n          \n          // 请求立即计算完整的命盘数据\n          await processBaziCalculation(resultId);\n          \n          // 跳转到结果页面\n          redirectToResultPage(resultId);\n        } else {\n          Toast.fail(response?.data?.message || '支付处理失败');\n          isProcessing.value = false;\n        }\n      } catch (error) {\n        console.error('支付处理出错:', error);\n        \n        // 错误处理：尝试构造默认结果ID\n        Toast.clear();\n        Toast.fail('支付处理出错，将使用默认结果ID');\n        \n        // 构造默认结果ID\n        const defaultResultId = 'RES' + orderId.value.replace(/^BZ/, '');\n        console.log('使用默认结果ID:', defaultResultId);\n        \n        // 尝试计算和跳转\n        await processBaziCalculation(defaultResultId);\n        \n        // 即使出错也跳转到结果页面，使用默认结果ID\n        redirectToResultPage(defaultResultId);\n      } finally {\n        isProcessing.value = false;\n      }\n    };\n    \n    // 提取八字计算过程为独立函数\n    const processBaziCalculation = async (resultId) => {\n      try {\n        Toast.loading({\n          message: '正在生成八字命盘...',\n          duration: 0,\n          forbidClick: true\n        });\n        \n        // 获取基础URL，确保在不同环境下都能正确请求API\n        const baseUrl = process.env.VUE_APP_API_URL || window.location.origin;\n        console.log('使用API基础URL:', baseUrl);\n        \n        // 添加重试机制\n        let retryCount = 0;\n        const maxRetries = 3;\n        let updateSuccess = false;\n        \n        while (retryCount < maxRetries && !updateSuccess) {\n          try {\n            // 修改：使用正确的update API端点\n            console.log(`正在请求更新八字数据 (尝试 ${retryCount + 1}/${maxRetries}):`, resultId);\n            const updateResponse = await axios.post(`${baseUrl}/api/bazi/update/${resultId}`, {\n              birthDate,\n              birthTime,\n              gender,\n              calendarType,\n              birthPlace,\n              livingPlace,\n              focusAreas,\n              forceRecalculate: true,        // 强制重新计算基础数据\n              generateShenshaData: true,     // 生成神煞数据\n              generateDayunData: true,       // 生成大运数据 \n              generateLiunianData: true,     // 生成流年数据\n              useDeepseekAPI: true           // 使用DeepSeek API进行分析\n            });\n            \n            console.log('八字数据更新响应:', updateResponse.data);\n            \n            if (updateResponse.data.code === 200) {\n              updateSuccess = true;\n              Toast.success('命盘数据生成中');\n              \n              // 确保延迟足够长，以便后端完成八字数据处理\n              setTimeout(async () => {\n                try {\n                  console.log('正在请求八字深度分析:', resultId);\n                  const analyzeResponse = await axios.post(`${baseUrl}/api/bazi/analyze/${resultId}`, {\n                    useDeepseekAPI: true\n                  });\n                  console.log('八字深度分析响应:', analyzeResponse.data);\n                  Toast.success('命盘分析已开始');\n                } catch (analyzeError) {\n                  console.error('深度分析请求失败:', analyzeError);\n                  // 即使分析请求失败，也继续流程，不阻止用户查看结果\n                  Toast.fail('命盘深度分析请求失败，但可以继续查看基础结果');\n                }\n              }, 3000); // 延长等待时间到3秒\n              \n              break; // 成功后跳出循环\n            } else {\n              console.error('八字数据更新失败:', updateResponse.data.message);\n              // 失败后重试\n              await new Promise(resolve => setTimeout(resolve, 1000));\n              retryCount++;\n            }\n          } catch (error) {\n            console.error(`更新请求失败 (尝试 ${retryCount + 1}/${maxRetries}):`, error);\n            \n            // 如果是404错误，可能是结果记录还未创建，尝试手动更新订单状态\n            if (error.response && error.response.status === 404) {\n              console.log('结果记录不存在，尝试手动更新订单状态');\n              try {\n                const manualResponse = await axios.get(`${baseUrl}/api/order/manual_update/${orderId.value}`);\n                console.log('手动更新响应:', manualResponse.data);\n                \n                if (manualResponse.data.code === 200 && manualResponse.data.data.resultId) {\n                  // 使用手动更新返回的resultId\n                  const updatedResultId = manualResponse.data.data.resultId;\n                  console.log('手动更新成功，获取到新的结果ID:', updatedResultId);\n                  \n                  // 更新当前使用的resultId\n                  resultId = updatedResultId;\n                }\n              } catch (manualError) {\n                console.error('手动更新失败:', manualError);\n              }\n            }\n            \n            // 失败后重试\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            retryCount++;\n          }\n        }\n        \n        if (!updateSuccess) {\n          Toast.fail('命盘计算请求失败，请稍后在结果页面刷新重试');\n          console.error('达到最大重试次数，八字数据更新失败');\n        }\n      } catch (calcError) {\n        console.error('命盘计算请求失败:', calcError);\n        Toast.fail('命盘计算请求失败，但您仍可以查看结果页面');\n      }\n    };\n    \n    // 添加结果页面跳转函数\n    const redirectToResultPage = (resultId) => {\n      // 延迟跳转，给用户体验更好的过渡\n      setTimeout(() => {\n        router.push({\n          path: `/result/${resultId}`,\n          query: {\n            birthDate,\n            birthTime,\n            gender,\n            birthPlace,\n            livingPlace,\n            originalOrderId: orderId.value // 传递原始订单ID\n          }\n        });\n      }, 1000);\n    };\n    \n    const checkPaymentStatus = async () => {\n      if (isProcessing.value) return;\n      \n      isProcessing.value = true;\n      Toast.loading({\n        message: '正在查询支付状态...',\n        duration: 0,\n        forbidClick: true\n      });\n      \n      try {\n        const response = await axios.get(`/api/order/query/${orderId.value}`);\n        console.log('支付状态查询响应:', response.data);\n        \n        if (response.data.code === 200 && response.data.data.status === 'paid') {\n          // 支付成功，继续处理\n          onPaymentSuccess();\n        } else {\n          Toast.fail('未检测到支付完成，请确认支付或稍后再试');\n          isProcessing.value = false;\n        }\n      } catch (error) {\n        console.error('查询支付状态失败:', error);\n        Toast.fail('查询支付状态失败');\n        isProcessing.value = false;\n      }\n    };\n    \n    // 添加轮询支付状态的方法\n    let paymentStatusInterval = null;\n    \n    const startPaymentStatusPolling = () => {\n      // 每5秒查询一次支付状态\n      paymentStatusInterval = setInterval(async () => {\n        try {\n          const response = await axios.get(`/api/order/query/${orderId.value}`);\n          console.log('轮询支付状态:', response.data);\n          \n          if (response.data.code === 200 && response.data.data.status === 'paid') {\n            // 支付成功，停止轮询并处理\n            clearInterval(paymentStatusInterval);\n            onPaymentSuccess();\n          }\n        } catch (error) {\n          console.error('轮询支付状态失败:', error);\n        }\n      }, 5000);\n    };\n    \n    // 在显示二维码时开始轮询，在组件销毁时清除轮询\n    watch(showQRCode, (newVal) => {\n      if (newVal) {\n        startPaymentStatusPolling();\n      } else if (paymentStatusInterval) {\n        clearInterval(paymentStatusInterval);\n      }\n    });\n    \n    onUnmounted(() => {\n      if (paymentStatusInterval) {\n        clearInterval(paymentStatusInterval);\n      }\n    });\n\n    return {\n      orderId,\n      createTime,\n      paymentMethod,\n      showQRCode,\n      qrCodeUrl,\n      isProcessing,\n      onClickLeft,\n      onPayment,\n      onPaymentSuccess,\n      checkPaymentStatus\n    };\n  }\n};\n</script>\n\n<style scoped>\n.payment-container {\n  padding-bottom: 20px;\n}\n\n.payment-method {\n  display: flex;\n  align-items: center;\n}\n\n.payment-name {\n  margin-left: 10px;\n}\n\n.payment-action {\n  padding: 20px 16px;\n}\n\n.qrcode-container {\n  padding: 20px;\n  text-align: center;\n  width: 280px;\n}\n\n.qrcode {\n  width: 200px;\n  height: 200px;\n  margin: 20px auto;\n  background-color: #f2f3f5;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: 1px solid #ebedf0;\n  border-radius: 4px;\n  overflow: hidden;\n}\n\n.qrcode iframe {\n  border: none;\n  width: 100%;\n  height: 100%;\n}\n\n.qrcode img {\n  max-width: 100%;\n  max-height: 100%;\n}\n\n.qrcode-placeholder {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: #969799;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}